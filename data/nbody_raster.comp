#version 450 core

#define NBODY_RENDER_SIZE 1024u

layout(local_size_x = NBODY_RENDER_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) buffer in_pos_buffer_t {
	vec4 positions[];
} in_pos_buffer;
layout(set = 0, binding = 1) buffer img_t {
	uint data[];
} img;
layout(set = 0, binding = 2) buffer img_old_t {
	uint data[];
} img_old;
layout(set = 0, binding = 3) buffer raster_params {
	mat4 mview;
	uvec2 img_size;
	vec2 mass_minmax;
	uint body_count;
} params;

mat4 perspective(const float fov, const float aspect, const float z_near, const float z_far) {
	const float f = 1.0 / tan(fov * 0.00872664625997);
	mat4 ret = {
		{ f / aspect, 0.0, 0.0, 0.0 },
		{ 0.0, f, 0.0, 0.0 },
		{ 0.0, 0.0, (z_far + z_near) / (z_near - z_far), -1.0 },
		{ 0.0, 0.0, (2.0 * z_far * z_near) / (z_near - z_far), 0.0 }
	};
	return ret;
}

vec3 compute_gradient(const float interpolator) {
	const vec3 gradients[4] = {
		{ 1.0, 0.2, 0.0 },
		{ 1.0, 1.0, 0.0 },
		{ 1.0, 1.0, 1.0 },
		{ 0.5, 1.0, 1.0 }
	};
	
	// scale from [0, 1] to [0, range]
	const float scaled_interp = interpolator * 4.0;
	// determine lower gradient idx
	const uint gradient_idx = min(uint(scaled_interp), 2u);
	// interp range is [0, 1] between gradients, just need to wrap/mod it
	const float wrapped_interp = mod(scaled_interp, 1.0f);
	// linear interpolation between gradients
	return mix(gradients[gradient_idx], gradients[gradient_idx + 1u], wrapped_interp);
}

void main() {
	const uint local_idx = gl_LocalInvocationID.x;
	const uint idx = NBODY_RENDER_SIZE * gl_WorkGroupID.x + local_idx;
	img_old.data[idx] = 0;
	
	if(idx >= params.body_count) return;
	
	const mat4 mproj = perspective(90.0, float(params.img_size.x) / float(params.img_size.y), 0.25, 2500.0);
	
	// transform vector (*TMVP)
	const vec3 mview_vec = (params.mview * vec4(in_pos_buffer.positions[idx].xyz, 1.0)).xyz;
	vec3 proj_vec = (mproj * vec4(mview_vec, 1.0)).xyz;
	
	// check if point is not behind cam
	if(mview_vec.z >= 0.0) return;
	proj_vec *= -1.0 / mview_vec.z;
	
	// and finally: compute window position
	ivec2 pixel = {
		int(float(params.img_size.x) * (proj_vec.x * 0.5 + 0.5)),
		int(float(params.img_size.y) * (proj_vec.y * 0.5 + 0.5))
	};
	
	const uvec2 upixel = pixel; // this also makes sure that negative positions are ignored
	if(upixel.x < params.img_size.x && upixel.y < params.img_size.y) {
		// compute gradient color, will just ignore alpha blending here
		const vec3 color_f = floor(compute_gradient((in_pos_buffer.positions[idx].w - params.mass_minmax.x) / (params.mass_minmax.y - params.mass_minmax.x)) * 255.0);
		const uint color = (((uint(color_f.z) & 0xFFu) << 16u) | ((uint(color_f.y) & 0xFFu) << 8u) | (uint(color_f.x) & 0xFFu));
		
		// OR the color value, this is kind of hack, but it works quite well with the colors we have (and faster than a add+CAS loop)
		atomicOr(img.data[upixel.y * params.img_size.x + upixel.x], color);
	}
}
